// Code generated by counterfeiter. DO NOT EDIT.
package solverfakes

import (
	"sync"

	"github.com/mhv2109/uci-impl/internal/solver"
)

type FakeSolver struct {
	DoMoveStub        func(string)
	doMoveMutex       sync.RWMutex
	doMoveArgsForCall []struct {
		arg1 string
	}
	GetOptionStub        func(string) *string
	getOptionMutex       sync.RWMutex
	getOptionArgsForCall []struct {
		arg1 string
	}
	getOptionReturns struct {
		result1 *string
	}
	getOptionReturnsOnCall map[int]struct {
		result1 *string
	}
	GetOptionsStub        func() []*solver.Option
	getOptionsMutex       sync.RWMutex
	getOptionsArgsForCall []struct {
	}
	getOptionsReturns struct {
		result1 []*solver.Option
	}
	getOptionsReturnsOnCall map[int]struct {
		result1 []*solver.Option
	}
	PonderHitStub        func()
	ponderHitMutex       sync.RWMutex
	ponderHitArgsForCall []struct {
	}
	SetOptionStub        func(string, string)
	setOptionMutex       sync.RWMutex
	setOptionArgsForCall []struct {
		arg1 string
		arg2 string
	}
	SetPositionStub        func(string, ...string)
	setPositionMutex       sync.RWMutex
	setPositionArgsForCall []struct {
		arg1 string
		arg2 []string
	}
	SetStartPositionStub        func(...string)
	setStartPositionMutex       sync.RWMutex
	setStartPositionArgsForCall []struct {
		arg1 []string
	}
	StartSearchStub        func(*solver.SearchParams, ...string) chan []string
	startSearchMutex       sync.RWMutex
	startSearchArgsForCall []struct {
		arg1 *solver.SearchParams
		arg2 []string
	}
	startSearchReturns struct {
		result1 chan []string
	}
	startSearchReturnsOnCall map[int]struct {
		result1 chan []string
	}
	StopSearchStub        func()
	stopSearchMutex       sync.RWMutex
	stopSearchArgsForCall []struct {
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSolver) DoMove(arg1 string) {
	fake.doMoveMutex.Lock()
	fake.doMoveArgsForCall = append(fake.doMoveArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("DoMove", []interface{}{arg1})
	fake.doMoveMutex.Unlock()
	if fake.DoMoveStub != nil {
		fake.DoMoveStub(arg1)
	}
}

func (fake *FakeSolver) DoMoveCallCount() int {
	fake.doMoveMutex.RLock()
	defer fake.doMoveMutex.RUnlock()
	return len(fake.doMoveArgsForCall)
}

func (fake *FakeSolver) DoMoveCalls(stub func(string)) {
	fake.doMoveMutex.Lock()
	defer fake.doMoveMutex.Unlock()
	fake.DoMoveStub = stub
}

func (fake *FakeSolver) DoMoveArgsForCall(i int) string {
	fake.doMoveMutex.RLock()
	defer fake.doMoveMutex.RUnlock()
	argsForCall := fake.doMoveArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSolver) GetOption(arg1 string) *string {
	fake.getOptionMutex.Lock()
	ret, specificReturn := fake.getOptionReturnsOnCall[len(fake.getOptionArgsForCall)]
	fake.getOptionArgsForCall = append(fake.getOptionArgsForCall, struct {
		arg1 string
	}{arg1})
	fake.recordInvocation("GetOption", []interface{}{arg1})
	fake.getOptionMutex.Unlock()
	if fake.GetOptionStub != nil {
		return fake.GetOptionStub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getOptionReturns
	return fakeReturns.result1
}

func (fake *FakeSolver) GetOptionCallCount() int {
	fake.getOptionMutex.RLock()
	defer fake.getOptionMutex.RUnlock()
	return len(fake.getOptionArgsForCall)
}

func (fake *FakeSolver) GetOptionCalls(stub func(string) *string) {
	fake.getOptionMutex.Lock()
	defer fake.getOptionMutex.Unlock()
	fake.GetOptionStub = stub
}

func (fake *FakeSolver) GetOptionArgsForCall(i int) string {
	fake.getOptionMutex.RLock()
	defer fake.getOptionMutex.RUnlock()
	argsForCall := fake.getOptionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSolver) GetOptionReturns(result1 *string) {
	fake.getOptionMutex.Lock()
	defer fake.getOptionMutex.Unlock()
	fake.GetOptionStub = nil
	fake.getOptionReturns = struct {
		result1 *string
	}{result1}
}

func (fake *FakeSolver) GetOptionReturnsOnCall(i int, result1 *string) {
	fake.getOptionMutex.Lock()
	defer fake.getOptionMutex.Unlock()
	fake.GetOptionStub = nil
	if fake.getOptionReturnsOnCall == nil {
		fake.getOptionReturnsOnCall = make(map[int]struct {
			result1 *string
		})
	}
	fake.getOptionReturnsOnCall[i] = struct {
		result1 *string
	}{result1}
}

func (fake *FakeSolver) GetOptions() []*solver.Option {
	fake.getOptionsMutex.Lock()
	ret, specificReturn := fake.getOptionsReturnsOnCall[len(fake.getOptionsArgsForCall)]
	fake.getOptionsArgsForCall = append(fake.getOptionsArgsForCall, struct {
	}{})
	fake.recordInvocation("GetOptions", []interface{}{})
	fake.getOptionsMutex.Unlock()
	if fake.GetOptionsStub != nil {
		return fake.GetOptionsStub()
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.getOptionsReturns
	return fakeReturns.result1
}

func (fake *FakeSolver) GetOptionsCallCount() int {
	fake.getOptionsMutex.RLock()
	defer fake.getOptionsMutex.RUnlock()
	return len(fake.getOptionsArgsForCall)
}

func (fake *FakeSolver) GetOptionsCalls(stub func() []*solver.Option) {
	fake.getOptionsMutex.Lock()
	defer fake.getOptionsMutex.Unlock()
	fake.GetOptionsStub = stub
}

func (fake *FakeSolver) GetOptionsReturns(result1 []*solver.Option) {
	fake.getOptionsMutex.Lock()
	defer fake.getOptionsMutex.Unlock()
	fake.GetOptionsStub = nil
	fake.getOptionsReturns = struct {
		result1 []*solver.Option
	}{result1}
}

func (fake *FakeSolver) GetOptionsReturnsOnCall(i int, result1 []*solver.Option) {
	fake.getOptionsMutex.Lock()
	defer fake.getOptionsMutex.Unlock()
	fake.GetOptionsStub = nil
	if fake.getOptionsReturnsOnCall == nil {
		fake.getOptionsReturnsOnCall = make(map[int]struct {
			result1 []*solver.Option
		})
	}
	fake.getOptionsReturnsOnCall[i] = struct {
		result1 []*solver.Option
	}{result1}
}

func (fake *FakeSolver) PonderHit() {
	fake.ponderHitMutex.Lock()
	fake.ponderHitArgsForCall = append(fake.ponderHitArgsForCall, struct {
	}{})
	fake.recordInvocation("PonderHit", []interface{}{})
	fake.ponderHitMutex.Unlock()
	if fake.PonderHitStub != nil {
		fake.PonderHitStub()
	}
}

func (fake *FakeSolver) PonderHitCallCount() int {
	fake.ponderHitMutex.RLock()
	defer fake.ponderHitMutex.RUnlock()
	return len(fake.ponderHitArgsForCall)
}

func (fake *FakeSolver) PonderHitCalls(stub func()) {
	fake.ponderHitMutex.Lock()
	defer fake.ponderHitMutex.Unlock()
	fake.PonderHitStub = stub
}

func (fake *FakeSolver) SetOption(arg1 string, arg2 string) {
	fake.setOptionMutex.Lock()
	fake.setOptionArgsForCall = append(fake.setOptionArgsForCall, struct {
		arg1 string
		arg2 string
	}{arg1, arg2})
	fake.recordInvocation("SetOption", []interface{}{arg1, arg2})
	fake.setOptionMutex.Unlock()
	if fake.SetOptionStub != nil {
		fake.SetOptionStub(arg1, arg2)
	}
}

func (fake *FakeSolver) SetOptionCallCount() int {
	fake.setOptionMutex.RLock()
	defer fake.setOptionMutex.RUnlock()
	return len(fake.setOptionArgsForCall)
}

func (fake *FakeSolver) SetOptionCalls(stub func(string, string)) {
	fake.setOptionMutex.Lock()
	defer fake.setOptionMutex.Unlock()
	fake.SetOptionStub = stub
}

func (fake *FakeSolver) SetOptionArgsForCall(i int) (string, string) {
	fake.setOptionMutex.RLock()
	defer fake.setOptionMutex.RUnlock()
	argsForCall := fake.setOptionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSolver) SetPosition(arg1 string, arg2 ...string) {
	fake.setPositionMutex.Lock()
	fake.setPositionArgsForCall = append(fake.setPositionArgsForCall, struct {
		arg1 string
		arg2 []string
	}{arg1, arg2})
	fake.recordInvocation("SetPosition", []interface{}{arg1, arg2})
	fake.setPositionMutex.Unlock()
	if fake.SetPositionStub != nil {
		fake.SetPositionStub(arg1, arg2...)
	}
}

func (fake *FakeSolver) SetPositionCallCount() int {
	fake.setPositionMutex.RLock()
	defer fake.setPositionMutex.RUnlock()
	return len(fake.setPositionArgsForCall)
}

func (fake *FakeSolver) SetPositionCalls(stub func(string, ...string)) {
	fake.setPositionMutex.Lock()
	defer fake.setPositionMutex.Unlock()
	fake.SetPositionStub = stub
}

func (fake *FakeSolver) SetPositionArgsForCall(i int) (string, []string) {
	fake.setPositionMutex.RLock()
	defer fake.setPositionMutex.RUnlock()
	argsForCall := fake.setPositionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSolver) SetStartPosition(arg1 ...string) {
	fake.setStartPositionMutex.Lock()
	fake.setStartPositionArgsForCall = append(fake.setStartPositionArgsForCall, struct {
		arg1 []string
	}{arg1})
	fake.recordInvocation("SetStartPosition", []interface{}{arg1})
	fake.setStartPositionMutex.Unlock()
	if fake.SetStartPositionStub != nil {
		fake.SetStartPositionStub(arg1...)
	}
}

func (fake *FakeSolver) SetStartPositionCallCount() int {
	fake.setStartPositionMutex.RLock()
	defer fake.setStartPositionMutex.RUnlock()
	return len(fake.setStartPositionArgsForCall)
}

func (fake *FakeSolver) SetStartPositionCalls(stub func(...string)) {
	fake.setStartPositionMutex.Lock()
	defer fake.setStartPositionMutex.Unlock()
	fake.SetStartPositionStub = stub
}

func (fake *FakeSolver) SetStartPositionArgsForCall(i int) []string {
	fake.setStartPositionMutex.RLock()
	defer fake.setStartPositionMutex.RUnlock()
	argsForCall := fake.setStartPositionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeSolver) StartSearch(arg1 *solver.SearchParams, arg2 ...string) chan []string {
	fake.startSearchMutex.Lock()
	ret, specificReturn := fake.startSearchReturnsOnCall[len(fake.startSearchArgsForCall)]
	fake.startSearchArgsForCall = append(fake.startSearchArgsForCall, struct {
		arg1 *solver.SearchParams
		arg2 []string
	}{arg1, arg2})
	fake.recordInvocation("StartSearch", []interface{}{arg1, arg2})
	fake.startSearchMutex.Unlock()
	if fake.StartSearchStub != nil {
		return fake.StartSearchStub(arg1, arg2...)
	}
	if specificReturn {
		return ret.result1
	}
	fakeReturns := fake.startSearchReturns
	return fakeReturns.result1
}

func (fake *FakeSolver) StartSearchCallCount() int {
	fake.startSearchMutex.RLock()
	defer fake.startSearchMutex.RUnlock()
	return len(fake.startSearchArgsForCall)
}

func (fake *FakeSolver) StartSearchCalls(stub func(*solver.SearchParams, ...string) chan []string) {
	fake.startSearchMutex.Lock()
	defer fake.startSearchMutex.Unlock()
	fake.StartSearchStub = stub
}

func (fake *FakeSolver) StartSearchArgsForCall(i int) (*solver.SearchParams, []string) {
	fake.startSearchMutex.RLock()
	defer fake.startSearchMutex.RUnlock()
	argsForCall := fake.startSearchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSolver) StartSearchReturns(result1 chan []string) {
	fake.startSearchMutex.Lock()
	defer fake.startSearchMutex.Unlock()
	fake.StartSearchStub = nil
	fake.startSearchReturns = struct {
		result1 chan []string
	}{result1}
}

func (fake *FakeSolver) StartSearchReturnsOnCall(i int, result1 chan []string) {
	fake.startSearchMutex.Lock()
	defer fake.startSearchMutex.Unlock()
	fake.StartSearchStub = nil
	if fake.startSearchReturnsOnCall == nil {
		fake.startSearchReturnsOnCall = make(map[int]struct {
			result1 chan []string
		})
	}
	fake.startSearchReturnsOnCall[i] = struct {
		result1 chan []string
	}{result1}
}

func (fake *FakeSolver) StopSearch() {
	fake.stopSearchMutex.Lock()
	fake.stopSearchArgsForCall = append(fake.stopSearchArgsForCall, struct {
	}{})
	fake.recordInvocation("StopSearch", []interface{}{})
	fake.stopSearchMutex.Unlock()
	if fake.StopSearchStub != nil {
		fake.StopSearchStub()
	}
}

func (fake *FakeSolver) StopSearchCallCount() int {
	fake.stopSearchMutex.RLock()
	defer fake.stopSearchMutex.RUnlock()
	return len(fake.stopSearchArgsForCall)
}

func (fake *FakeSolver) StopSearchCalls(stub func()) {
	fake.stopSearchMutex.Lock()
	defer fake.stopSearchMutex.Unlock()
	fake.StopSearchStub = stub
}

func (fake *FakeSolver) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.doMoveMutex.RLock()
	defer fake.doMoveMutex.RUnlock()
	fake.getOptionMutex.RLock()
	defer fake.getOptionMutex.RUnlock()
	fake.getOptionsMutex.RLock()
	defer fake.getOptionsMutex.RUnlock()
	fake.ponderHitMutex.RLock()
	defer fake.ponderHitMutex.RUnlock()
	fake.setOptionMutex.RLock()
	defer fake.setOptionMutex.RUnlock()
	fake.setPositionMutex.RLock()
	defer fake.setPositionMutex.RUnlock()
	fake.setStartPositionMutex.RLock()
	defer fake.setStartPositionMutex.RUnlock()
	fake.startSearchMutex.RLock()
	defer fake.startSearchMutex.RUnlock()
	fake.stopSearchMutex.RLock()
	defer fake.stopSearchMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSolver) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ solver.Solver = new(FakeSolver)
